{"version":3,"file":"useIncidents-Bx07qVBD.js","sources":["../../src/hooks/useIncidents.ts"],"sourcesContent":["import { useState, useEffect, useCallback, useMemo } from 'react';\nimport { supabase } from '@/integrations/supabase/client';\nimport { RealtimeChannel } from '@supabase/supabase-js';\n\nexport interface Incident {\n  id: string;\n  service_id: string | null;\n  author_id: string | null;\n  title: string;\n  title_en: string | null;\n  description: string;\n  description_en: string | null;\n  status: 'investigating' | 'identified' | 'monitoring' | 'resolved';\n  created_at: string;\n  updated_at: string;\n  resolved_at: string | null;\n  position: number;\n  services: { name: string } | null;\n  profiles: { first_name: string | null, last_name: string | null, email: string | null, avatar_url: string | null } | null;\n}\n\nexport const useIncidents = () => {\n  const [incidents, setIncidents] = useState<Incident[]>([]);\n  const [loading, setLoading] = useState(true);\n\n  const fetchIncidents = useCallback(async () => {\n    const { data, error } = await supabase\n      .from('incidents')\n      .select('*, services(name), profiles!author_id(first_name, last_name, email, avatar_url)')\n      .order('position');\n    \n    if (error) {\n      console.error('Erreur lors de la récupération des incidents:', error);\n    } else {\n      setIncidents(data as any[] || []);\n    }\n    setLoading(false);\n  }, []);\n\n  useEffect(() => {\n    fetchIncidents();\n\n    const channel: RealtimeChannel = supabase\n      .channel('incidents-changes')\n      .on(\n        'postgres_changes',\n        {\n          event: '*',\n          schema: 'public',\n          table: 'incidents',\n        },\n        () => {\n          fetchIncidents();\n        }\n      )\n      .subscribe();\n\n    return () => {\n      supabase.removeChannel(channel);\n    };\n  }, [fetchIncidents]);\n\n  // Fonction pour forcer le rafraîchissement\n  const refreshIncidents = useCallback(() => {\n    fetchIncidents();\n  }, [fetchIncidents]);\n\n  // Mémoisation des données calculées pour éviter les re-renders\n  const activeIncidents = useMemo(() => \n    incidents.filter(i => i.status !== 'resolved' && i.status !== 'postmortem'), \n    [incidents]\n  );\n\n  const resolvedIncidents = useMemo(() => \n    incidents.filter(i => i.status === 'resolved'), \n    [incidents]\n  );\n\n  return { \n    incidents, \n    loading, \n    refreshIncidents,\n    activeIncidents,\n    resolvedIncidents\n  };\n};"],"names":["useIncidents","incidents","setIncidents","useState","loading","setLoading","fetchIncidents","useCallback","__async","data","error","supabase","useEffect","channel","refreshIncidents","activeIncidents","useMemo","i","resolvedIncidents"],"mappings":"8RAqBO,MAAMA,EAAe,IAAM,CAChC,KAAM,CAACC,EAAWC,CAAY,EAAIC,EAAAA,SAAqB,CAAA,CAAE,EACnD,CAACC,EAASC,CAAU,EAAIF,EAAAA,SAAS,EAAI,EAErCG,EAAiBC,EAAAA,YAAY,IAAYC,EAAA,sBAC7C,KAAM,CAAE,KAAAC,EAAM,MAAAC,CAAA,EAAU,MAAMC,EAC3B,KAAK,WAAW,EAChB,OAAO,iFAAiF,EACxF,MAAM,UAAU,EAEfD,EACF,QAAQ,MAAM,gDAAiDA,CAAK,EAEpER,EAAaO,GAAiB,EAAE,EAElCJ,EAAW,EAAK,CAClB,GAAG,CAAA,CAAE,EAELO,EAAAA,UAAU,IAAM,CACdN,EAAA,EAEA,MAAMO,EAA2BF,EAC9B,QAAQ,mBAAmB,EAC3B,GACC,mBACA,CACE,MAAO,IACP,OAAQ,SACR,MAAO,WAAA,EAET,IAAM,CACJL,EAAA,CACF,CAAA,EAED,UAAA,EAEH,MAAO,IAAM,CACXK,EAAS,cAAcE,CAAO,CAChC,CACF,EAAG,CAACP,CAAc,CAAC,EAGnB,MAAMQ,EAAmBP,EAAAA,YAAY,IAAM,CACzCD,EAAA,CACF,EAAG,CAACA,CAAc,CAAC,EAGbS,EAAkBC,EAAAA,QAAQ,IAC9Bf,EAAU,OAAOgB,GAAKA,EAAE,SAAW,YAAcA,EAAE,SAAW,YAAY,EAC1E,CAAChB,CAAS,CAAA,EAGNiB,EAAoBF,EAAAA,QAAQ,IAChCf,EAAU,OAAOgB,GAAKA,EAAE,SAAW,UAAU,EAC7C,CAAChB,CAAS,CAAA,EAGZ,MAAO,CACL,UAAAA,EACA,QAAAG,EACA,iBAAAU,EACA,gBAAAC,EACA,kBAAAG,CAAA,CAEJ"}